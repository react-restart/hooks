{"componentChunkName":"component---node-modules-docpocalypse-gatsby-theme-src-templates-hook-tsx","path":"/api/useMounted","result":{"data":{"docpocalypse":{"id":"bb1b31b6-f717-5a9f-8f54-d6d1ef3bb018","tsType":{"id":"70cecdc1-e9e0-53a5-b38f-6c168ef137e3","name":"useMounted","kind":64,"kindString":"Function","flags":{"isExported":true},"signatures":[{"id":"11a6b12a-3dc6-54e7-a429-314a7ac9f3f0","name":"useMounted","kind":4096,"kindString":"Call signature","flags":{"isExported":true},"type":{"type":"reflection","declaration":{"id":"42fb9bff-e212-5586-a624-9f80ac914344","name":"__type","kind":65536,"kindString":"Type literal","flags":{"isExported":true},"signatures":[{"id":"7e091af5-f0ad-5bd6-80e0-8a2f4a4664cd","name":"__call","kind":4096,"kindString":"Call signature","flags":{"isExported":true},"type":{"type":"intrinsic","name":"boolean"},"parent":"42fb9bff-e212-5586-a624-9f80ac914344","rootDir":"/Users/brianreed/iambriansreed/hooks/src","tsconfig":"/Users/brianreed/iambriansreed/hooks/tsconfig.json","typedocs":[],"signatures":[],"parameters":[],"typeParameter":[],"groups":[],"absolutePath":"/Users/brianreed/iambriansreed/hooks/src/useMounted.ts"}],"parent":"11a6b12a-3dc6-54e7-a429-314a7ac9f3f0","rootDir":"/Users/brianreed/iambriansreed/hooks/src","tsconfig":"/Users/brianreed/iambriansreed/hooks/tsconfig.json","typedocs":[],"parameters":[],"typeParameter":[],"groups":[],"absolutePath":"/Users/brianreed/iambriansreed/hooks/src/useMounted.ts"}},"parent":"70cecdc1-e9e0-53a5-b38f-6c168ef137e3","rootDir":"/Users/brianreed/iambriansreed/hooks/src","tsconfig":"/Users/brianreed/iambriansreed/hooks/tsconfig.json","typedocs":[],"signatures":[],"parameters":[],"typeParameter":[],"groups":[],"absolutePath":"/Users/brianreed/iambriansreed/hooks/src/useMounted.ts","description":{"id":"5731cfec-a9ad-565c-9769-b2fb222cb16d","parent":"11a6b12a-3dc6-54e7-a429-314a7ac9f3f0","mdx":{"id":"f97e6e58-13df-559c-a17d-5503315b4011","parent":"5731cfec-a9ad-565c-9769-b2fb222cb16d","frontmatter":{"title":""},"exports":{},"rawBody":"Track whether a component is current mounted. Generally less preferable than\nproperlly canceling effects so they don't run after a component is unmounted,\nbut helpful in cases where that isn't feasible, such as a `Promise` resolution.","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Track whether a component is current mounted. Generally less preferable than\\nproperlly canceling effects so they don't run after a component is unmounted,\\nbut helpful in cases where that isn't feasible, such as a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Promise\"), \" resolution.\"));\n}\n;\nMDXContent.isMDXComponent = true;"},"markdownRemark":{"id":"73b7500e-ad35-5ab6-aaa1-0f79d78feda8","parent":"5731cfec-a9ad-565c-9769-b2fb222cb16d","frontmatter":{"title":""},"excerpt":"","rawMarkdownBody":"Track whether a component is current mounted. Generally less preferable than\nproperlly canceling effects so they don't run after a component is unmounted,\nbut helpful in cases where that isn't feasible, such as a `Promise` resolution.","html":"<p>Track whether a component is current mounted. Generally less preferable than\nproperlly canceling effects so they don't run after a component is unmounted,\nbut helpful in cases where that isn't feasible, such as a <code>Promise</code> resolution.</p>"}},"returnsDescription":{"id":"4fd06e12-babb-5ea0-b631-9f6eea1df92b","parent":"11a6b12a-3dc6-54e7-a429-314a7ac9f3f0","mdx":{"id":"2cf13698-cd95-5596-835a-a908ef398907","parent":"4fd06e12-babb-5ea0-b631-9f6eea1df92b","frontmatter":{"title":""},"exports":{},"rawBody":"a function that returns the current isMounted state of the component\n\n```ts\nconst [data, setData] = useState(null)\nconst isMounted = useMounted()\n\nuseEffect(() => {\n  fetchdata().then((newData) => {\n     if (isMounted()) {\n       setData(newData);\n     }\n  })\n})\n```\n","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"a function that returns the current isMounted state of the component\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"const [data, setData] = useState(null)\\nconst isMounted = useMounted()\\n\\nuseEffect(() => {\\n  fetchdata().then((newData) => {\\n     if (isMounted()) {\\n       setData(newData);\\n     }\\n  })\\n})\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"},"markdownRemark":{"id":"6a49b46c-3c3d-5f7f-9b55-c447a2050e8e","parent":"4fd06e12-babb-5ea0-b631-9f6eea1df92b","frontmatter":{"title":""},"excerpt":"","rawMarkdownBody":"a function that returns the current isMounted state of the component\n\n```ts\nconst [data, setData] = useState(null)\nconst isMounted = useMounted()\n\nuseEffect(() => {\n  fetchdata().then((newData) => {\n     if (isMounted()) {\n       setData(newData);\n     }\n  })\n})\n```\n","html":"<p>a function that returns the current isMounted state of the component</p>\n<pre><code class=\"language-ts\">const [data, setData] = useState(null)\nconst isMounted = useMounted()\n\nuseEffect(() => {\n  fetchdata().then((newData) => {\n     if (isMounted()) {\n       setData(newData);\n     }\n  })\n})\n</code></pre>"}}}],"parent":"76116f5a-8e1d-5c2c-a346-cf470bd18e13","rootDir":"/Users/brianreed/iambriansreed/hooks/src","tsconfig":"/Users/brianreed/iambriansreed/hooks/tsconfig.json","typedocs":[],"parameters":[],"typeParameter":[],"groups":[],"absolutePath":"/Users/brianreed/iambriansreed/hooks/src/useMounted.ts"},"type":"hook","name":"useMounted","packageName":"@restart/hooks","importName":"import useMounted from '@restart/hooks/useMounted'","tags":[{"name":"returns","value":"a function that returns the current isMounted state of the component\n\n```ts\nconst [data, setData] = useState(null)\nconst isMounted = useMounted()\n\nuseEffect(() => {\n  fetchdata().then((newData) => {\n     if (isMounted()) {\n       setData(newData);\n     }\n  })\n})\n```"}],"example":null,"signatures":[{"kind":"function","name":"useMounted","description":{"childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Track whether a component is current mounted. Generally less preferable than\\nproperlly canceling effects so they don't run after a component is unmounted,\\nbut helpful in cases where that isn't feasible, such as a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Promise\"), \" resolution.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"examples":[],"type":null,"params":null,"properties":null,"optional":false,"returns":[{"name":null,"description":{"childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"a function that returns the current isMounted state of the component\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"const [data, setData] = useState(null)\\nconst isMounted = useMounted()\\n\\nuseEffect(() => {\\n  fetchdata().then((newData) => {\\n     if (isMounted()) {\\n       setData(newData);\\n     }\\n  })\\n})\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"optional":false,"type":{"name":null,"type":"FunctionType","elements":null,"expression":null,"applications":null}}],"members":{"static":null}}]}},"pageContext":{"nodeId":"bb1b31b6-f717-5a9f-8f54-d6d1ef3bb018","exampleId":null}}}